# Design document

Revision C : <time>2023-03-06</time>

This is a very terse design document for a small webserver code named
`okayws`, intended to be an "okay web server" that makes it easy for
clubs, teams or those running a small newsletter to run a small,
stateless website.

![okayws icon](okayws.png)

I've had experience of running a company
[Django](https://www.djangoproject.com/) website without a database, and
of helping maintain a static document site built using
[Sphinx](https://www.sphinx-doc.org/en/master/). Based on those I think
a small web server that has web pages described simply with markdown
files would work well for small websites. The static website builder
[Hugo](https://gohugo.io/) is great, but `okayws` can be simpler and
more opinionated, to make it easier to get a site up-and-running, but
also run the site in production.

Markdown is a very simple way of defining web pages using simple text
formatting instructions. For example text after a \# describes a level 1
header, while text between \*\* symbols will be shown in **bold**. See
the [github markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)
page for more information about this type of markdown. 

Apart from content, though, a user will also have to find, modify or
create a css style sheet and possibly modify two or three templates.

## Operation

`okayws` will be a single go binary available for Windows, Mac and
Linux.

Websites would be expected to be structured as follows:

```
    website
    ├── content
    ├── media
    └── templates
```

The `content` directory will hold markdown formatted files with the
website contents. The `media` directory will hold media files, such as
css and js files, together with other resources such as images and
movies. The `templates` directory will hold the templates (using go's
simple but powerful `html/template` templating format) that will wrap
the content.

The urls will be generated by the content. A content structure like
this:

```
    content
    ├── home.md
    ├── about.md
    ├── pelagic
    │   ├── herring.md
    │   └── mackerel.md
    └── scarabs
        ├── home.md
        ├── dung_beetles.md
        ├── .dung_beetles.md
        ├── Goliath Beetles.html
        └── june-beetles.md
```

...would generate the following urls and associated resources:

```
url                      : resource
-----------------------------------------------------
/                        : home.md
/about                   : about.md
/pelagic/herring         : pelagic/herring.md
/pelagic/mackarel        : pelagic/mackarel.md
/scarabs                 : scarabs/home.md
/scarabs/dung-beetles    : scarabs/dung_beetles.md
/scarabs/goliath-beetles : scarabs/Goliath Beetles.md
/scarabs/june-beetles    : scarabs/june-beetles.md
```

The special name `home.md` provides a home page for the directory. In
the example above the url `/scarabs` will show the content in
`/scarabs/home.md` while `/pelagic` has no `home.md` resource so will
result in a "page not found". Note how resources with spaces or underbar
characters have renamed urls, with the file extension removed. Note that
the temporary file `.dung_beetles.md` is not included in the url tree
and consequently will not be served. Files prefixed with a `_` character
will also not be served.

The templates in the `templates` directory will be `home.html` and
`article.html` for wrapping the website contents. A `home_inner.html`
template can also be specified for home pages in sections.

The `okayws` server can be run in production or development mode. The
default will be development mode. If it is run in development mode and
no `website`, `templates` or `media` directories exist, the program will
halt. Default content can be made using the `init` verb.

```
# initialise a site
okayws init 

# run in development mode
okayws serve

# run in production mode
okayws --production serve <project_directory>

# compile static html pages
okayws compile <output_directory>

```

To show updates to the website content, the server will re-read the
filesystem  when it encounters a Control-D (^D) signal.

In production mode page content may be gzipped into a cache for faster
performance.

## Tags

A very limited number of go html template tags can be used in the
files in the `templates` directory.

### Page Tags

The following per-page tags are available:

```
{{ .Content }}
```

The `.Content` tag holds the html from the markdown file associated with
the page.

```
{{ .URL }}
```
The `.URL` tag is the url of the current page.

```
{{ .Title }}
```

The `.Title` is the title of a page, which is extracted from the first
`<h1>...</h1>` encountered for a page, otherwise the url will be used.
This tag is normally only used in templates.

```
{{ .Summary }}
```
The `.Summary` is the summary of a page, taken from the first 100 words
from the first `<p>...</p>` paragraph block (if any).

```
{{ .Date }}
```
The `.Date` is the date of the article or webpage, based either on the
first `<time>...</time>` inline html in the article, or otherwise the
date from the last modified timestamp of the file on the filesystem.

```
{{ .Depth }}
```
The `.Depth` is the depth of the current page in the site. A top level
page such as `/about` has a depth of 1, while `/scarabs/beetles/dung`
would have a level of 3.

```
{{ .Section }}
```
The `.Section` is the url of this section. For `/scarabs/beetles/dung`
it would be `/scarabs/beetles`, for `/about` it would be `/`.

### Site Tags

The following site tags, which are tags defining content for the whole
site, are available:

```
{{ .Menu }}
```

The `.Menu` tag outputs the URL and Title of each section in the site,
together with other top level elements.

In the example case, the menu would contain `Home`, `About`, `Scarabs` and
`Pelagic` (the latter would point to `/pelagic/herring` as the `pelagic`
section has no home page).

```
{{ .Pages }}
```
The `.Pages` tag provides a list of the pages in the site, by default in
the alphabetical order of the urls of the site. Each page is represented
by its URL, Title, Description and an Active flag, which is true for the
currently viewed page. This tag can be used to construct menus or
indexes.

Pages can be sorted with the following methods:
`.Pages.SortByURL` and `.Pages.SortByTitle`.

Pages can be limited to a slice of no longer than `len` by using the
"Len" function. For example `.Pages.SortByURL.Len 5` will provide at
most 5 pages. (The golang `slice` function could be used but could panic
if an insufficient number of items are available.)

Page listings can be filtered by section using `.Pages.Section <name>`.
For example, if one was viewing `/scarabs/goliath-beetles`, the tag `{{
.Pages.Section "/scarabs" }}` or `{{ .Pages.Section .Section }}` will
limit the list of pages to those in the `scarabs` directory.

```
{{ nextPage }} and {{ previousPage }}
```

The `nextPage` and `previousPage` functions provide the following or
preceding page in a page list. Typically it would be used in a construct
such as `{{ nextPage .Pages }}` or `{{ previousPage (.Pages.Section
.Section) }}`. The former invocation will provide the next page across
the site, so if one was viewing `/scarabs/june-beetles`, the next page
it would jump to is `/`. In the latter case if one was viewing
`/scarabs/dung-beetles` the previous page would be
`/scarabs/june-beetles` as the pages are constrained to the `scarabs`
section of the site.

## Other stuff

It would be great if the entire website could be read from a zip, tgz or
tbz archive. A verb such as `zip` could be added to the binary to help
prepare the archive file, e.g. `./okayws zip`. Prodcution releases would
then need just the binary and archive file and be run like this
`./okayws --production web.zip`.

## Not included

I've considered the following and I've decided, so far, not to include
them:

1. page summaries
   
   each webpage (described by an `.md` file, could have a section at the
   top in yaml format, much in the same way as Huge supports
   [frontmatter](https://gohugo.io/content-management/front-matter/). The
   entry could look something like this:

   ```
   # yaml format
   title: the title that will show in the browser
   # dates would allow articles to be listed in chronological order, or
   # help build a list of (say) the last 5 articles.
   date: 2022-12-13
   description: >
       this is the summary description that can be multi-line and show
       as a summary in an article listing
   ```

   This complexity can be avoided by setting the title from the text
   from the first heading (`<h1>...</h1>`), the date from the
   last-modified date from the file on the filesystem, and a summary
   from the first paragraph of the article prose. Of these the date is
   the most tricky.

2. image processing
   
   Hugo has some pretty impressive [image processing
   capabilities](https://gohugo.io/content-management/image-processing/)
   but most people can crop and resize images pretty easily. The most
   useful thing `okayws` could do is resize images for different screen
   types and (arguably) remove exif data.

   Creating a set of images optimised for reading on different screens
   is discussed in several blog posts, including [Responsive and
   optimized images with Hugo](https://www.brycewray.com/posts/2022/06/responsive-optimized-images-hugo/)
   and [Responsive Images in Hugo](https://www.adamwills.io/blog/responsive-images-hugo/).

   One thought is that for large (> 1200px wide images) a smaller image
   will be generated, say 600px wide, together with a LQIP low-quality
   background for placeholders. The two images will be grouped together
   in an html `srcset`. This doesn't necessarily solve the "art
   direction problem" discussed on the Mozilla [responsive
   images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)
   page though. Perhaps 3 sizes might be needed -- full-size, medium and
   small. This (together with other great suggestions in the article
   series) is set out on Jason Grigsby's article (one of a set) at
   [Responsive Images 101, Part 6: Picture Element](https://cloudfour.com/thinks/responsive-images-101-part-6-picture-element/).
   The Shopify example has three images: desktop (`min-width:990px`),
   tablet (`min-width:750px`) and a default (for mobile) for sizes under
   that. Note that this example has fixed-width images, otherwise
   `srcset` widths and sizes should be used, as he describes at
   [How does the browser select the correct sizes value?](https://cloudfour.com/thinks/responsive-images-101-part-5-sizes/)
   in section 5 of the same article series.

   Based on the above and a default arrangement of generating 4 images
   for big images (LQIP, mobile, tablet and desktop), `okayws` could
   assess all `<img>` html attributes and the resulting resources to
   determine if 1) alternative sizes should be generated and 2) rewrite
   the `<img>` node to include `srcset` and `sizes` attributes.

   The user could stop the system auto-generating alternative sizes by
   specifying a flag, such as `--no-image-processing`. If a different
   sort of (art-directed) image is needed at different sizes, the user
   should simply ensure that the alternative images that they save
   manually are saved _after_ the base image.

3. auto refreshing on file change

   If a content file changes it is necessary that okayws re-read the
   content and the browser refreshed. This is possible to automate using
   `fsnotify` to watch for filesystem change events and an automatic
   browser refresher, probably using javascript and web sockets.

   This feature isn't considered important for the time being; getting
   the server to refresh on hitting `^D` would work fine.

